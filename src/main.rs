use anyhow::{Result, anyhow};
use clap::{Args, Parser, Subcommand};
use reqwest::header::CONTENT_TYPE;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::HashMap;
use uuid::Uuid;

use std::env;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a DNS entry.
    Gen(Gen),
    /// Deletes a DNS entry.
    Del(Del),
    /// Lists existing DNS entries.
    ListIds(ListIds),
}

#[derive(Args)]
struct Gen {
    /// Resource Record for the DNS record
    rr_type: Option<String>,

    /// Defaults to 127.0.0.1
    entry_content: Option<String>,
}

#[derive(Args)]
struct ListIds {
    /// Whether or not to list only domains that have been auto-generated with this tool.
    /// Default: true
    onlyautogenerated: Option<bool>,

    /// Whether the output should be formatted as CSV.
    /// Default: false
    csvoutput: Option<bool>,
}

#[derive(Args)]
struct Del {
    id: Option<String>,
}

fn _dns_type_supported(_entry_type: &str) -> bool {
    let supported_types = std::vec!["A", "AAAA"];
    supported_types.contains(&_entry_type)
}

fn create_dns_entry(cf_api_key: &str, entry_type: &str, zone_id: &str, target: &str) -> Result<()> {
    if !_dns_type_supported(entry_type) {
        println!("DNS Entry Type {} currently not supported.", entry_type)
    }

    let request_url = format!(
        "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
        zone_id
    );

    let id = Uuid::new_v4();
    let new_domain = format!("{}", id);

    let payload = json!({
        "name": new_domain,
        "ttl": 60,
        "type": entry_type,
        "comment": "Auto-generated DNS record -- Leave unchanged! --.",
        "content": target,
        "proxied": false
    });

    let client = reqwest::blocking::Client::new();
    let _response = client
        .post(request_url)
        .header(CONTENT_TYPE, "application/json")
        .bearer_auth(cf_api_key)
        .json(&payload)
        .send()?;

    if _response.status().is_success() {
        println!("{}", new_domain);
        return Ok(());
    }

    return Err(anyhow!("Could not query Cloudflare API successfully."));
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse {
    #[serde(default)]
    pub errors: Vec<ApiMessage>,
    #[serde(default)]
    pub messages: Vec<ApiMessage>,
    pub success: bool,
    #[serde(default)]
    pub result: Vec<DnsRecord>,
    pub result_info: Option<ResultInfo>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiMessage {
    pub code: Option<u32>,
    pub message: Option<String>,
    pub documentation_url: Option<String>,
    pub source: Option<Source>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Source {
    pub pointer: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DnsRecord {
    pub name: String,
    pub ttl: Option<u32>,
    #[serde(rename = "type")]
    pub record_type: Option<String>,
    pub comment: Option<String>,
    pub content: Option<String>,
    pub proxied: Option<bool>,
    pub settings: Option<DnsSettings>,
    #[serde(default)]
    pub tags: Vec<String>,
    pub id: Option<String>,
    pub created_on: Option<String>,
    #[serde(default)]
    pub meta: HashMap<String, serde_json::Value>,
    pub modified_on: Option<String>,
    pub proxiable: Option<bool>,
    pub comment_modified_on: Option<String>,
    pub tags_modified_on: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DnsSettings {
    pub ipv4_only: Option<bool>,
    pub ipv6_only: Option<bool>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResultInfo {
    pub count: Option<u32>,
    pub page: Option<u32>,
    pub per_page: Option<u32>,
    pub total_count: Option<u32>,
}

fn print_domains(domains: &HashMap<String, String>, csvoutput: bool) {
    if csvoutput {
        println!("domain,id");
        for (domain, id) in domains {
            println!("{},{}", domain, id)
        }

        return;
    }

    let domain_width = domains.keys().map(|k| k.len()).max().unwrap_or(6).max(6);

    let id_width = domains.values().map(|v| v.len()).max().unwrap_or(2).max(2);

    println!("Total: {} domain(s)\n", domains.len());

    println!("{:<domain_width$} | {:<id_width$}", "Domain", "ID");
    println!("{:-<domain_width$}-+-{:-<id_width$}", "", "");

    for (domain, id) in domains {
        println!("{:<domain_width$} | {:<id_width$}", domain, id);
    }
}

fn list_domain_ids(
    cf_api_key: &str,
    zone_id: &str,
    only_auto_generated: bool,
    csvoutput: bool,
) -> Result<()> {
    let request_url = format!(
        "https://api.cloudflare.com/client/v4/zones/{}/dns_records",
        zone_id
    );

    let client = reqwest::blocking::Client::new();
    let _response = client.get(request_url).bearer_auth(cf_api_key).send()?;

    if !_response.status().is_success() {
        return Err(anyhow!("Could not query Cloudflare API successfully."));
    }

    let _response_body = _response.text().expect("Could not read response");
    let _parsed_body: ApiResponse = serde_json::from_str(&_response_body)?;

    let mut domain_map: HashMap<String, String> = HashMap::new();
    for domain in _parsed_body.result.iter() {
        if only_auto_generated {
            let comment = domain.comment.clone().unwrap_or("".to_string());
            if comment != "Auto-generated DNS record -- Leave unchanged! --." {
                continue;
            }
        }
        let id = domain.id.clone().unwrap_or("<Unknown>".to_string());
        domain_map.insert(domain.name.clone(), id);
    }

    print_domains(&domain_map, csvoutput);

    Ok(())
}

fn delete_domain(cf_api_key: &str, zone_id: &str, domain_id: &str) -> Result<()> {
    let request_url = format!(
        "https://api.cloudflare.com/client/v4/zones/{}/dns_records/{}",
        zone_id, domain_id
    );

    let client = reqwest::blocking::Client::new();
    let _response = client.delete(request_url).bearer_auth(cf_api_key).send()?;

    if !_response.status().is_success() {
        return Err(anyhow!("Could not query Cloudflare API successfully."));
    }

    Ok(())
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let zone_id = env::var("ZONE_ID")?;
    let cf_apikey = env::var("CLOUDFLARE_API_KEY")?;

    match &cli.command {
        Commands::Gen(args) => {
            let rr_type = args.rr_type.clone().expect("Expected a given RR type.");
            let entry_content = args
                .entry_content
                .clone()
                .unwrap_or("127.0.0.1".to_string());

            return create_dns_entry(&cf_apikey, &rr_type, &zone_id, &entry_content);
        }

        Commands::ListIds(args) => {
            let only_auto_generated = args.onlyautogenerated.clone().unwrap_or(true);
            let csvoutput = args.csvoutput.clone().unwrap_or(false);

            return list_domain_ids(&cf_apikey, &zone_id, only_auto_generated, csvoutput);
        }

        Commands::Del(args) => {
            let domain_id = args.id.clone().expect("Missing ID of domain to delete.");
            return delete_domain(&cf_apikey, &zone_id, &domain_id);
        }
    }
}
